/* Программа балансировки роторов в 1 и 2 плоскостях             */
/* А.Э.Головнев  Тел.69-71-98                03.93г. Волгоград   */

    /* Балансировка в одной плоскости по 2 замерам               */
    /*                                                           */
    /* Исходные данные:                                          */
    /* А -Амплитуда на оборотной частоте 1 замер                 */
    /* В -Фаза на оборотной частоте 1 замер                      */
    /* С -Амплитуда на оборотной частоте 2 замер (после уст. груза)*/
    /* D -Фаза --------------------------------------------------*/
    /* Е -Вес установленного груза                               */
    /* G -Фаза -------------------                               */
    /*                                                           */
    /* Выходные данные:                                          */
    /* К -Коэффициент жесткости                                  */
        /* F -Угол запаздывания                                      */
#include<stdio.h>
#include<math.h>
#define RD 57.2956   /* Градусов в радиане */
void s0(),s1(),s2(),s3(),s4(),s5(),s6(),s7(),s8(),s9(),s50(),s150();
float q,w,e,r,t,y,u,o,p,a,s,d,f,g,h,k,l,z,x,c,v,b,n,m,del;
int i,j;
char name[30],pr;
main()
  {printf("\n0. 1p.2m\n1. 1p.k\n2. 2p.2m\n3. 2p.k\n4. Del. Mass\n");
A:scanf("%d",&i);
  switch(i)
        {case 0: s0(); return;
        case 1:   s1(); return;
        case 2:   s2(); return;
        case 3:   s3(); return;
        case 4:   s4(); return;
        default: goto A;
    }
  }
void
s0(void)
  {printf("\n1p.2m\tinsert\nA1\tF1\tA2\tF2\tMG\tFG\n");
  scanf("%f%f%f%f%f%f",&a,&b,&c,&d,&e,&g); s=a; t=b;
  u=c; v=d; s9();
  k=s/e; f=t-g; printf("k=%f\tf=%f",k,f);
  flushall();   pr=getch();
  if(pr=='p')
        {fprintf(stdout,"\n1p.2m\nA1=%f\tF1=%f\nA2=%f\tF2=%f\nMG=%f\tFG=%f\n",a,b,c,d,e,g);
        fprintf(stdout,"k=%f\tf=%f",k,f);
        }
  s8();
  }

    /* Балансировка в одной плоскости по к-ту жесткости          */
    /* (ввод исх данн)                                           */
    /*                                                           */
    /* Исходные данные:                                          */
    /* А -Амплитуда на оборотной частоте                         */
    /* В -Фаза на оборотной частоте                              */
    /* С -Приравнено А                                           */
    /* D -Приравнено В                                           */
    /* К -Коэффициент жесткости                                  */
    /* F -Угол запаздывания                                      */

void
s1()
  {printf("1p.k\t insert\nA1\tF1\tK\tFZ\n");
  scanf("%f%f%f%f",&a,&b,&k,&f);
  c=a; d=b;
  flushall();   pr=getch();
  if(pr=='p')
        {fprintf(stdout,"\n1p.k\nA1=%f\tF1=%f\nK=%f\tFZ=%f\n",a,b,k,f);
        }
  s8();
  }

    /* Балансировка в двух плоскостях по 2 замерам               */
    /*                                                           */
    /* Исходные данные:                                          */
    /* А -Амплитуда на оборотной частоте 1 замер 1 плоскость     */
    /* В -Фаза на оборотной частоте 1 замер 1 плоскость          */
    /* С -Амплитуда на оборотной частоте 1 замер 2 плоскость     */
    /* D -Фаза --------------------------------------------------*/
    /*                                                           */
    /* U -Амплитуда на оборотной частоте 2 замер j-ая плоскость  */
    /* V -Фаза на оборотной частоте 2 замер j-ая плоскость (j=1 и*/
    /* E -Амплитуда на оборотной частоте 2 замер j-ая плоскость  */
    /* R -Фаза --------------------------------------------------*/
    /* О -Вес установленного груза                               */
    /* Р -Фаза -------------------                               */
    /*                                                           */
    /* Выходные данные:                                          */
    /* К -Коэффициент жесткости по 1 плоскости, когда груз в 1 пл*/
    /* F -Угол запаздывания     ---------------------------------*/
    /* М -Коэффициент жесткости по 2 плоскости, когда груз в 1 пл*/
    /* N -Угол запаздывания     ---------------------------------*/
    /* X -Коэффициент жесткости по 1 плоскости, когда груз в 2 пл*/
    /* Y -Угол запаздывания     ---------------------------------*/
    /* G -Коэффициент жесткости по 2 плоскости, когда груз в 2 пл*/
    /* H -Угол запаздывания     ---------------------------------*/

void
s2()
  {printf("2p.2m\tinsert\nBeg A1\tF1\tA2\tF2\n");
  scanf("%f%f%f%f",&a,&b,&c,&d); s=a; t=b;
  printf("\nmass in pl ");scanf("%d",&j);
  printf("insert\na1\tf1\ta2\tf2\tmg\tfg\n");
  scanf("%f%f%f%f%f%f",&u,&v,&e,&r,&o,&p);
  s9();
  if(j==1)
    {k=s/o; f=t-p;}
  else
    {x=s/o; y=t-p;}
  s=c; t=d; u=e; v=r; s9();
  if(j!=1)
    {g=s/o; h=t-p;
    printf("\nk12=%f\tf12=%f\tk22=%f\tf22=%f",x,y,g,h);
    }
  else
    {m=s/o; n=t-p;
    printf("\nk11=%f\tf11=%f\tk21=%f\tf21=%f\t",k,f,m,n);
    }
  printf("\n1 -Расчет коэффициентов\n2 -Расчет уравновешивающих грузов\n");
C:scanf("%d",&i);
  switch(i)
    {case 1:   s2(); return;
    case 2:   s6(); return;
    default: goto C;
    }
  }

    /* Балансировка в двух плоскостях по коэффициентам жесткости  */
    /*                                                            */
    /* Исходные данные:                                           */
    /* А -Амплитуда на оборотной частоте 1 плоскость              */
    /* В -Фаза на оборотной частоте 1 плоскость                   */
    /* С -Амплитуда на оборотной частоте 2 плоскость              */
    /* D -Фаза -------------------------------------              */
    /* К -Коэффициент жесткости по 1 плоскости, когда груз в 1 пло*/
    /* F -Угол запаздывания     ----------------------------------*/
    /* М -Коэффициент жесткости по 2 плоскости, когда груз в 1 пло*/
    /* N -Угол запаздывания     ----------------------------------*/
    /* X -Коэффициент жесткости по 1 плоскости, когда груз в 2 пло*/
    /* Y -Угол запаздывания     ----------------------------------*/
    /* G -Коэффициент жесткости по 2 плоскости, когда груз в 2 пло*/
    /* H -Угол запаздывания     ----------------------------------*/

void
s3()
  {printf("\n2p.k insert\nA1\tF1\tA2\tF2\n");
  scanf("%f%f%f%f",&a,&b,&c,&d);
  printf("\ninsert\nPar K11\tF11\tK21\tF21\n");
  scanf("%f%f%f%f",&k,&f,&m,&n);
  printf("\ninsert\nK12\tF12\tK22\tF22\n");
  scanf("%f%f%f%f",&x,&y,&g,&h); s6();
  }

    /* Раскладка груза по местам установки                        */
    /*                                                            */
    /* Исходные данные:                                           */
    /* R -Модуль (Масса) груза                                    */
    /* O -Фаза установки груза                                    */
    /* I -Угол разбивки груза                                     */

void
s4()
  {printf("\ninsert angle Del");
  scanf("%d",&i);
B:printf("\ninsert Mass\tFaz\n");
  scanf("%f%f",&r,&o); z=(int)(o/i)*i; h=z+i;
  printf("\n%f Gr\t%f Grad",(r*sin((double)(h-o)/RD)/sin((double)(180-i)/RD)),z);
  if(h>=360) h=h-360;
  printf("\n%f Gr\t%f Grad",r*sin((double)(o-z)/RD)/sin((double)(180-i)/RD),h);
  goto B;
  }
    /* Расчет уравновешивающего груза по к-там жесткости          */

void
s6()
  {q=a*cos((double)b/RD); w=a*sin((double)b/RD);
  a=c*cos((double)d/RD); b=c*sin((double)d/RD);
  c=k*cos((double)f/RD); d=k*sin((double)f/RD);
  k=m*cos((double)n/RD); f=m*sin((double)n/RD);
  m=x*cos((double)y/RD); n=x*sin((double)y/RD);
  x=g*cos((double)h/RD); y=g*sin((double)h/RD);
  e=m*k-n*f-x*c+y*d; r=m*f+n*k-x*d-y*c;
  o=e*e+r*r;
  if(o==0) {printf("\nsymmetric"); s3();}
  g=q*x-w*y-a*m+b*n; h=q*y+w*x-a*n-b*m;
  printf("\npl1 "); s150();
  g=a*c-b*d-q*k+w*f; h=a*d+b*c-q*f-w*k;
  printf("\npl2 "); s150(); s4();
  }
void
s150()
  {z=(g*e+h*r)/o; v=(h*e-g*r)/o; s7();
  printf("%f Gr\t%d Grad",s,(int)t);
  }

    /* Подпрограмма перевода вектора из прямоугольных координат   */
    /* в полярные                                                 */
    /*                                                            */
    /* Исходные данные:                                           */
    /* Z -Координата вектора x                                    */
    /* V -Координата y                                            */
    /*                                                            */
    /* Выходные данные:                                           */
    /* S -Модуль вектора                                          */
    /* T -Фаза                                                    */

void
s7()
  {if(z==0)
    {s=fabs((double)v); t=90;
    if(v<0);t=270;
    }
  else
    {s=sqrt((double)(v*v+z*z)); t=atan((double)(v/z))*RD;
    if(z<0) t=t+180;
    else
      {if(v<0) t=t+360;}
    }
  }
    /* Подпрограмма расчета уравновешивающей массы по к-ту        */
    /* жесткости в одной пл.                                      */

void
s8()
  {printf("\nm.no\t");
  if(pr=='p')   fprintf(stdout,"\nm.no\t");
  s50();
  a=c; b=d; printf("\nm.yes\t");
  if(pr=='p')   fprintf(stdout,"\nm.yes\t");
  s50();
  s4();
  }
void
s50()
  {q=b-f+180;
  while(q>=360) q=q-360;
  printf("\nMass=%f\t%d Grad",a/k,(int)q);
  if(pr=='p')   fprintf(stdout,"\nMass=%f\t%d Grad",a/k,(int)q);
  }

    /* Подпрограмма вычитания векторов 2ой минус 1ый              */
    /*                                                            */
    /* Исходные данные:                                           */
    /* S -Модуль вектора 1                                        */
    /* T -Фаза -----------                                        */
    /* U -Модуль вектора 2                                        */
    /* V -Фаза -----------                                        */
    /*                                                            */
    /* Выходные данные:                                           */
    /* S -Модуль вектора разностного                              */
    /* T -Фаза ---------------------                              */
    /*                                                            */
    /* Временные переменные: Z                                    */

void
s9()
  {z=u*cos((double)v/RD)-s*cos((double)t/RD);
  v=u*sin((double)v/RD)-s*sin((double)t/RD); s7();
  }